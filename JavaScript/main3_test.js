/* Задан массив чисел. 
Числа в массиве могут повторяться сколько угодно раз. 
Напиши функцию которая из такого массива вернет 
массив уникальных чисел. 
Основные требования:
- getUniques должна вернуть массив уникальных чисел;
- Порядок чисел в результирующем массиве не важен.*/
/*Отримання унікальних чисел з масиву можна здійснити за 
допомогою методу фільтрації унікальних значень. 
Ось приклад реалізації функції getUniques: */

function getUniques(arr) {
  return arr.filter((value, index, self) => {
    return self.indexOf(value) === index;
  });
}

// examples
console.log(getUniques([1, 2, 1, 5, 18, 5, 2, 1, 9])); // ===> [1, 2, 5, 18, 9]
console.log(getUniques([2, 2, 2, 2, 2, 5])); // ===> [2, 5]
console.log(getUniques([1])); // ===> [1]

/*У цьому випадку метод filter відфільтровує унікальні значення, 
порядок яких не важливий, і повертає новий масив, 
що містить лише унікальні числа з вхідного масиву. */
//--------------------------------------------------
//--------------------------------------------------
//--------------------------------------------------
//----------2 спосіб за допомогою цикла--------------
//--------------------------------------------------
//--------------------------------------------------
//--------------------------------------------------
function getUniques(arr) {
  const uniqueArray = [];
  for (let i = 0; i < arr.length; i++) {
    if (uniqueArray.indexOf(arr[i]) === -1) {
      uniqueArray.push(arr[i]);
    }
  }
  return uniqueArray;
}

// приклади
console.log(getUniques([1, 2, 1, 5, 18, 5, 2, 1, 9])); // ===> [1, 2, 5, 18, 9]
console.log(getUniques([2, 2, 2, 2, 2, 5])); // ===> [2, 5]
console.log(getUniques([1])); // ===> [1]
/*У цьому випадку ми використали цикл для перевірки кожного елементу у 
вхідному масиві та додавання його до нового масиву 
унікальних значень, якщо його там ще немає. 
Цей цикл використовується для проходження крізь кожен елемент масиву 
arr за допомогою змінної i. Умова i < arr.length гарантує, що цикл 
буде виконуватися для кожного елементу масиву.

У тілі циклу перевіряється, чи вже міститься поточний елемент 
arr[i] в масиві uniqueArray за допомогою методу indexOf.
Якщо елемент ще не міститься в uniqueArray 
(тобто uniqueArray.indexOf(arr[i]) повертає -1), 
то цей елемент додається до uniqueArray за допомогою методу push.

Отже, цей цикл додає до uniqueArray лише унікальні елементи 
з масиву arr, які ще не містяться в uniqueArray.*/
//--------------------------------------------------
//--------------------------------------------------
//--------------------------------------------------
//----------3 спосіб за допомогою цикла for _ of--------------
//--------------------------------------------------
//--------------------------------------------------
//--------------------------------------------------
function getUniques(arr) {
  const uniqueArray = [];
  for (const value of arr) {
    if (!uniqueArray.includes(value)) {
      uniqueArray.push(value);
    }
  }
  return uniqueArray;
}

// приклади
console.log(getUniques([1, 2, 1, 5, 18, 5, 2, 1, 9])); // ===> [1, 2, 5, 18, 9]
console.log(getUniques([2, 2, 2, 2, 2, 5])); // ===> [2, 5]
console.log(getUniques([1])); // ===> [1]
/*У цьому випадку ми використовуємо цикл for of для прогання 
через кожен елемент масиву arr. Якщо поточний елемент value ще 
не міститься в uniqueArray, то він додається до uniqueArray 
за допомогою методу push. В результаті ми отримуємо масив,
що містить лише унікальні значення.*/